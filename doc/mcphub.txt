*mcphub.nvim.txt*           For NVIM v0.10.0          Last change: 2025 May 17

==============================================================================
Table of Contents                              *mcphub.nvim-table-of-contents*

1. What is MCP HUB?                             |mcphub.nvim-what-is-mcp-hub?|
  - How does MCP Hub work?|mcphub.nvim-what-is-mcp-hub?-how-does-mcp-hub-work?|
  - Feature Support Matrix|mcphub.nvim-what-is-mcp-hub?-feature-support-matrix|
  - Next Steps                       |mcphub.nvim-what-is-mcp-hub?-next-steps|
2. Installation                                     |mcphub.nvim-installation|
  - Requirements                       |mcphub.nvim-installation-requirements|
  - Lazy.nvim                             |mcphub.nvim-installation-lazy.nvim|
  - NixOS                                     |mcphub.nvim-installation-nixos|
3. Configuration                                   |mcphub.nvim-configuration|
  - Default Configuration    |mcphub.nvim-configuration-default-configuration|
  - Binary mcp-hub Options  |mcphub.nvim-configuration-binary-mcp-hub-options|
  - Chat-Plugin Related Options|mcphub.nvim-configuration-chat-plugin-related-options|
  - Plugin Options                  |mcphub.nvim-configuration-plugin-options|
4. MCP Servers                                       |mcphub.nvim-mcp-servers|
  - MCP Config File                  |mcphub.nvim-mcp-servers-mcp-config-file|
  - Lua MCP Servers                  |mcphub.nvim-mcp-servers-lua-mcp-servers|
5. Extensions                                         |mcphub.nvim-extensions|
  - Avante Integration             |mcphub.nvim-extensions-avante-integration|
  - CodeCompanion Integration|mcphub.nvim-extensions-codecompanion-integration|
  - CopilotChat Integration  |mcphub.nvim-extensions-copilotchat-integration-|
  - Lualine Integration           |mcphub.nvim-extensions-lualine-integration|
6. Other                                                   |mcphub.nvim-other|
7. Links                                                   |mcphub.nvim-links|

==============================================================================
1. What is MCP HUB?                             *mcphub.nvim-what-is-mcp-hub?*

MCPHub.nvim is a MCP client for neovim that seamlessly integrates MCP (Model
Context Protocol) <https://modelcontextprotocol.io/> servers into your editing
workflow. It provides an intuitive interface for managing, testing, and using
MCP servers with your favorite chat plugins.


  [!IMPORTANT] It is recommended to read this page before going through the rest
  of the documentation.

HOW DOES MCP HUB WORK?   *mcphub.nvim-what-is-mcp-hub?-how-does-mcp-hub-work?*

Let‚Äôs break down how MCP Hub operates in simple terms:


MCP CONFIG FILE ~

Like any MCP client, MCP Hub requires a configuration file to define the MCP
servers you want to use. This file is typically located at
`~/.config/mcphub/servers.json`. MCP Hub supports local `stdio` servers as well
as remote `streamable-http` or `sse` servers. This is similar to
`claude_desktop_config.json` file for Claude desktop or `mcp.json` file used by
VSCode. In fact you can use the same file for MCP Hub as well with some
additional benefits. It looks something like:

>js
    // Example: ~/.config/mcphub/servers.json
    {
      "mcpServers": {
        "fetch": {
          "command": "uvx",
          "args": [
            "mcp-server-fetch"
          ]
        },
        "remote-server": {
          "url": "https://api.example.com/mcp"
        }
      }
    }
<


SERVERS MANAGER ~

- When MCP Hub‚Äôs `setup()` is called typically when Neovim starts, it launches the nodejs binary, mcp-hub <https://github.com/ravitemer/mcp-hub> with the `servers.json` file.
- The `mcp-hub` binary reads `servers.json` file and starts the MCP servers.
- It provides a express REST API endpoint (default: `http://localhost:37373`) for clients to interact with MCP servers
- The plugin communicates with this endpoint to:
    - Start/stop MCP servers
    - Execute tools, resources, prompts etc
    - Handle real-time server events when tools or resources are changed.


USAGE ~

- Use `:MCPHub` command to open the interface
- Adding (`<A>`), editing (`<e>`), deleting (`<d>`) MCP servers in easy and intuitive with MCP Hub. You don‚Äôt need to edit the `servers.json` file directly.
- Install servers from the Marketplace (`M`)
- Toggle servers, tools, and resources etc
- Test tools and resources directly in Neovim


CHAT INTEGRATIONS ~

- MCP Hub provides integrations with popular chat plugins like Avante <https://github.com/yetone/avante.nvim>, CodeCompanion <https://github.com/olimorris/codecompanion.nvim>, CopilotChat <https://github.com/CopilotC-Nvim/CopilotChat.nvim>.
- LLMs can use MCP servers through our `@mcp` tool.
- Resources show up as `#variables` in chat.
- Prompts become `/slash_commands`.


FEATURE SUPPORT MATRIX   *mcphub.nvim-what-is-mcp-hub?-feature-support-matrix*

  ---------------------------------------------------------------------------------
  Category             Feature              Support            Details
  -------------------- -------------------- ------------------ --------------------
  Capabilities                                                 

                       Tools                ‚úÖ                 Full support

                       üîî Tool List Changed ‚úÖ                 Real-time updates

                       Resources            ‚úÖ                 Full support

                       üîî Resource List     ‚úÖ                 Real-time updates
                       Changed                                 

                       Resource Templates   ‚úÖ                 URI templates

                       Prompts              ‚úÖ                 Full support

                       üîî Prompts List      ‚úÖ                 Real-time updates
                       Changed                                 

                       Roots                ‚ùå                 Not supported

                       Sampling             ‚ùå                 Not supported

  MCP Server                                                   
  Transports                                                   

                       Streamable-HTTP      ‚úÖ                 Primary transport
                                                               protocol for remote
                                                               servers

                       SSE                  ‚úÖ                 Fallback transport
                                                               for remote servers

                       STDIO                ‚úÖ                 For local servers

  Authentication for                                           
  remote servers                                               

                       OAuth                ‚úÖ                 With PKCE flow

                       Headers              ‚úÖ                 For API keys/tokens

  Chat Integration                                             

                       Avante.nvim          ‚úÖ                 Tools, resources,
                                                               resourceTemplates,
                                                               prompts(as
                                                               slash_commands)

                       CodeCompanion.nvim   ‚úÖ                 Tools, resources,
                                                               resourceTemplates,
                                                               prompts (as
                                                               slash_commands)

                       CopilotChat.nvim     ‚úÖ                 In-built support
                                                               Draft

  Marketplace                                                  

                       Server Discovery     ‚úÖ                 Browse from verified
                                                               MCP servers

                       Installation         ‚úÖ                 Manual and auto
                                                               install with AI

  Advanced                                                     

                       Smart File-watching  ‚úÖ                 Smart updates with
                                                               config file watching

                       Multi-instance       ‚úÖ                 All neovim instances
                                                               stay in sync

                       Shutdown-delay       ‚úÖ                 Can run as systemd
                                                               service with
                                                               configure delay
                                                               before stopping the
                                                               hub

                       Lua Native MCP       ‚úÖ                 Write once , use
                       Servers                                 everywhere. Can
                                                               write tools,
                                                               resources, prompts
                                                               directly in lua
  ---------------------------------------------------------------------------------

NEXT STEPS                           *mcphub.nvim-what-is-mcp-hub?-next-steps*

- Installation Guide </installation> - Set up MCPHub in your Neovim
- Configuration Guide </configuration> - Learn about configuring MCP Hub


==============================================================================
2. Installation                                     *mcphub.nvim-installation*

Please read the getting started </index> guide before reading this.


REQUIREMENTS                           *mcphub.nvim-installation-requirements*

- Neovim >= 0.8.0
- Node.js >= 18.0.0
- plenary.nvim <https://github.com/nvim-lua/plenary.nvim>
- mcp-hub <https://github.com/ravitemer/mcp-hub> (automatically installed via build command)


LAZY.NVIM                                 *mcphub.nvim-installation-lazy.nvim*

MCPHub.nvim requires mcp-hub <https://github.com/ravitemer/mcp-hub> to manage
MCP Servers. You can make `mcp-hub` binary available in three ways:

1. |mcphub.nvim-global-installation| (Recommended)
2. |mcphub.nvim-local-installation|
3. |mcphub.nvim-dev-installation|


DEFAULT INSTALLATION ~

Install `mcp-hub` node binary globally using `npm`, `yarn`, or `bun` any other
node package manager using the `build` command. The `build` command will run
everytime the plugin is updated.

>lua
    {
        "ravitemer/mcphub.nvim",
        dependencies = {
            "nvim-lua/plenary.nvim",
        },
        build = "npm install -g mcp-hub@latest",  -- Installs `mcp-hub` node binary globally
        config = function()
            require("mcphub").setup()
        end
    }
<

Please see configuration </configuration> for default plugin config and on how
to configure the plugin.


LOCAL INSTALLATION ~

Ideal for environments where global binary installations aren‚Äôt possible.

Download `mcp-hub` binary alongside the neovim plugin using `bundled_build.lua`
for the `build` command. We need to explicitly set `use_bundled_binary` to
`true` to let the plugin use the locally available `mcp-hub` binary.

>lua
    {
        "ravitemer/mcphub.nvim",
        dependencies = {
            "nvim-lua/plenary.nvim",
        },
        build = "bundled_build.lua",  -- Bundles `mcp-hub` binary along with the neovim plugin
        config = function()
            require("mcphub").setup({
                use_bundled_binary = true,  -- Use local `mcp-hub` binary
            })
        end,
    }
<


DEV INSTALLATION ~

Ideal for development. You can provide the command that our plugin should use
to start the `mcp-hub` server. You can clone the `mcp-hub` repo locally using
`gh clone ravitemer/mcp-hub` and provide the path to the `cli.js` as shown
below:

>lua
    {
        "ravitemer/mcphub.nvim",
        dependencies = {
            "nvim-lua/plenary.nvim",
        },
        config = function()
            require("mcphub").setup({
                cmd = "node",
                cmdArgs = {"/path/to/mcp-hub/src/utils/cli.js"},
            })
        end,
    }
<

See Contributing
<https://github.com/ravitemer/mcphub.nvim/blob/main/CONTRIBUTING.md> guide for
detailed development setup.


NIXOS                                         *mcphub.nvim-installation-nixos*

Flake install ~

Just add it to your NixOS flake.nix or home-manager:

>nix
    inputs = {
    mcphub-nvim.url = "github:ravitemer/mcphub.nvim";
    ...
    }
<

To integrate mcphub.nvim to your NixOS/Home Manager nvim configs, add the
following to your neovim.plugins
<https://nixos.wiki/wiki/Neovim#Installing_Plugins> or your neovim.packages
<https://nixos.wiki/wiki/Neovim#System-wide_2>

>nix
    inputs.mcphub-nvim.packages."${system}".default
<

and add the setup function in lua code
<https://nixos.wiki/wiki/Neovim#Note_on_Lua_plugins>


NIXVIM EXAMPLE ~

Nixvim <https://github.com/nix-community/nixvim> example:

>nix
    { mcphub-nvim, ... }:
    {
    extraPlugins = [mcphub-nvim];
    extraConfigLua = ''
    require("mcphub").setup()
    '';
    }
    
    # where
    {
    # For nixpkgs (not available yet)
    # ...
    
    # For flakes
    mcphub-nvim = inputs.mcphub-nvim.packages."${system}".default;
    }
<

Nixpkgs install ~


  coming‚Ä¶

==============================================================================
3. Configuration                                   *mcphub.nvim-configuration*

Please read the getting started </index> guide before reading this.


DEFAULT CONFIGURATION        *mcphub.nvim-configuration-default-configuration*

All options are optional with sensible defaults. See below for each option in
detail.

>lua
    {
        "ravitemer/mcphub.nvim",
        dependencies = {
            "nvim-lua/plenary.nvim",
        },
        build = "npm install -g mcp-hub@latest",  -- Installs `mcp-hub` node binary globally
        config = function()
            require("mcphub").setup({
                --- `mcp-hub` binary related options-------------------
                config = vim.fn.expand("~/.config/mcphub/servers.json"), -- Absolute path to MCP Servers config file (will create if not exists)
                port = 37373, -- The port `mcp-hub` server listens to
                shutdown_delay = 60 * 10 * 000, -- Delay in ms before shutting down the server when last instance closes (default: 10 minutes)
                use_bundled_binary = false, -- Use local `mcp-hub` binary (set this to true when using build = "bundled_build.lua")
    
                ---Chat-plugin related options-----------------
                auto_approve = false, -- Auto approve mcp tool calls
                auto_toggle_mcp_servers = true, -- Let LLMs start and stop MCP servers automatically
                extensions = {
                    avante = {
                        make_slash_commands = true, -- make /slash commands from MCP server prompts
                    }
                },
    
                --- Plugin specific options-------------------
                native_servers = {}, -- add your custom lua native servers here
                ui = {
                    window = {
                        width = 0.8, -- 0-1 (ratio); "50%" (percentage); 50 (raw number)
                        height = 0.8, -- 0-1 (ratio); "50%" (percentage); 50 (raw number)
                        relative = "editor",
                        zindex = 50,
                        border = "rounded", -- "none", "single", "double", "rounded", "solid", "shadow"
                    },
                    wo = { -- window-scoped options (vim.wo)
                        winhl = "Normal:MCPHubNormal,FloatBorder:MCPHubBorder",
                    },
                },
                on_ready = function(hub)
                    -- Called when hub is ready
                end,
                on_error = function(err)
                    -- Called on errors
                end,
                log = {
                    level = vim.log.levels.WARN,
                    to_file = false,
                    file_path = nil,
                    prefix = "MCPHub",
                },
            })
        end
    }
<


BINARY MCP-HUB OPTIONS      *mcphub.nvim-configuration-binary-mcp-hub-options*

On calling `require("mcphub").setup()`, MCPHub.nvim starts the `mcp-hub`
process with the given arguments. Internally the default command looks
something like:

>bash
    mcp-hub --config ~/.config/mcphub/servers.json --port 37373 --auto-shutdown --shutdown-delay 600000 --watch
<

We can configure how the `mcp-hub` process starts and stops as follows:


CONFIG ~

Default: `~/.config/mcphub/servers.json`

Absolute path to the MCP Servers configuration file. The plugin will create
this file if it doesn‚Äôt exist. See servers.json </mcp/servers_json> page to
see how `servers.json` should look like, how to safely add it to source control
and more


PORT ~

Default: `37373`

The port number that the `mcp-hub`‚Äôs express server should listen on.
MCPHub.nvim sends curl requests to `http://localhost:37373/` endpoint to manage
MCP servers. We first check if `mcp-hub` is already running before trying to
start a new one.


SERVER_URL ~

Default: `nil`

By default, we send curl requests to `http://localhost:37373/` to manage MCP
servers. However, in cases where you want to run `mcp-hub` on another machine
in your local network or remotely you can override the endpoint by setting this
to the server URL e.g `http://mydomain.com:customport` or
`https://url_without_need_for_port.com`


SHUTDOWN_DELAY ~

Default: `600000` (10 minutes)

Time in milliseconds to wait before shutting down the `mcp-hub` server when the
last Neovim instance closes. The `mcp-hub` server stays up for 10 minutes after
exiting neovim. On entering, MCPHub.nvim checks for the running server and
connects to it. This makes the MCP servers readily available. You can set it to
a longer time to keep `mcp-hub` running.


USE_BUNDLED_BINARY ~

Default: `false`

Uses local `mcp-hub` binary. Enable this when using `build =
"bundled_build.lua"` in your plugin configuration.


CMD, CMDARGS ~

Default: `nil`

Internally `cmd` points to the `mcp-hub` binary. e.g for global installations
it is `mcp-hub`. When `use_bundled_binary` is `true` it is
`~/.local/share/nvim/lazy/mcphub.nvim/bundled/mcp-hub/node_modules/mcp-hub/dist/cli.js`.
You can set this to something else so that MCPHub.nvim uses `cmd` and `cmdArgs`
to start the `mcp-hub` server. You can clone the `mcp-hub` repo locally using
`gh clone ravitemer/mcp-hub` and provide the path to the `cli.js` as shown
below:

>lua
    require("mcphub").setup({
        cmd = "node",
        cmdArgs = {"/path/to/mcp-hub/src/utils/cli.js"},
    })
<

See Contributing
<https://github.com/ravitemer/mcphub.nvim/blob/main/CONTRIBUTING.md> guide for
detailed development setup.


CHAT-PLUGIN RELATED OPTIONS*mcphub.nvim-configuration-chat-plugin-related-options*


AUTO_APPROVE ~

Default: `false`

By default when the LLM calls a tool or resource on a MCP server, we show a
confirmation window like below.

Set it to to `true` to automatically approve MCP tool calls without user
confirmation. This also sets `vim.g.mcphub_auto_approve` variable to `true`.
You can toggle this option in the MCP Hub UI with `ga` keymap. You can see the
current auto approval status in the Hub UI.


AUTO_TOGGLE_MCP_SERVERS ~

Default: `true`

Allow LLMs to automatically start and stop MCP servers as needed. Disable to
require manual server management. The following demo shows avante auto starting
a disabled MCP server to acheive it‚Äôs objective. See discussion
<https://github.com/ravitemer/mcphub.nvim/discussions/88> for details.


EXTENSIONS ~

Default:

>lua
    {
        extensions = {
            avante = {
                enabled = true,
                make_slash_commands = true
            }
        }
    }
<

Avante <https://github.com/yetone/avante.nvim> integration options: -
`make_slash_commands`: Convert MCP server prompts to slash commands in Avante
chat - Please visit Avante </extensions/avante> for full integration
documentation

Also see CodeCompanion </extensions/codecompanion>, CopilotChat
</extensions/copilotchat> pages for detailed setup guides.


PLUGIN OPTIONS                      *mcphub.nvim-configuration-plugin-options*


NATIVE_SERVERS ~

Default: `{}`

Define custom Lua native MCP servers that run directly in Neovim without
external processes. Each server can provide tools, resources, and prompts.
Please see native servers guide </mcp/native/index> to create MCP Servers in
lua.


UI ~

Default:

>lua
    {
        ui = {
            window = {
                width = 0.85, -- 0-1 (ratio); "50%" (percentage); 50 (raw number)
                height = 0.85, -- 0-1 (ratio); "50%" (percentage); 50 (raw number)
                border = "rounded", -- "none", "single", "double", "rounded", "solid", "shadow"
                relative = "editor",
                zindex = 50,
            },
            wo = { -- window-scoped options (vim.wo)
                winhl = "Normal:MCPHubNormal,FloatBorder:MCPHubBorder",
            },
        },
    }
<

Controls the appearance and behavior of the MCPHub UI window: - `width`: Window
width (0-1 for ratio, "50%" for percentage, or raw number) - `height`: Window
height (same format as width) - `relative`: Window placement relative to
("editor", "win", or "cursor") - `zindex`: Window stacking order - `border`:
Border style ("none", "single", "double", "rounded", "solid", "shadow")


ON_READY ~

Default: `function(hub) end`

Callback function executed when the MCP Hub server is ready and connected.
Receives the hub instance as an argument.


ON_ERROR ~

Default: `function(err) end`

Callback function executed when an error occurs in the MCP Hub server. Receives
the error message as an argument.


LOG ~

Default:

>lua
    {
        level = vim.log.levels.WARN,
        to_file = false,
        file_path = nil,
        prefix = "MCPHub"
    }
<

Logging configuration options: - `level`: Log level (vim.log.levels.ERROR,
WARN, INFO, DEBUG, TRACE) - `to_file`: Whether to write logs to file -
`file_path`: Custom log file path - `prefix`: Prefix for log messages


==============================================================================
4. MCP Servers                                       *mcphub.nvim-mcp-servers*


MCP CONFIG FILE                      *mcphub.nvim-mcp-servers-mcp-config-file*

MCPHub.nvim like other MCP clients uses a JSON configuration file to manage MCP
servers. This `config` file is located at `~/.config/mcphub/servers.json` by
default and supports real-time updates across all Neovim instances. You can set
`config` option to a custom location.


  [!NOTE] You can use a single config file for any MCP client like VSCode,
  Cursor, Cline, Zed etc as long as the config file follows the below structure.
  With MCPHub.nvim, `config` file can be safely added to source control as it
  allows some special placeholder values in the `env` and `headers` fields on MCP
  Servers.

MANAGE SERVERS ~

Adding, editing, deleting and securing MCP servers in easy and intuitive with
MCP Hub. You don‚Äôt need to edit the `servers.json` file directly. Everything
can be done right from the UI.


FROM MARKETPLACE


BROWSE, SORT, FILTER , SEARCH FROM AVAILABLE MCP SERVERS.


ONE CLICK AI INSTALL WITH AVANTE AND CODECOMPANION


OR SIMPLE COPY PASTE MCPSERVERS JSON BLOCK IN THE README




FROM HUB VIEW

Add (`<A>`), edit (`<e>`), delete (`<d>`) MCP servers from the (`H`) Hub view.


BASIC SCHEMA ~

The `config` file should have a `mcpServers` key. This contains `stdio` and
`remote` MCP servers. There is also another top level MCPHub specific field
`nativeMCPServers` to store any disabled tools, custom instructions etc that
the plugin updates internally. See Lua MCP Servers </mcp/native/index> for more
about Lua native MCP servers

>json
    {
        "mcpServers": {
            // Add stdio and remote MCP servers here
        },
        "nativeMCPServers": { // MCPHub specific
            // To store disabled tools, custom instructions etc
        }
    }
<


SERVER TYPES ~


LOCAL (STDIO) SERVERS

>json
    {
        "mcpServers": {
            "local-server": {
                "command": "uvx",
                "args": ["mcp-server-fetch"]
            }
        }
    }
<


REQUIRED FIELDS:

- `command`: The executable to start the server


OPTIONAL FIELDS:

- `args`: Array of command arguments
- `env`: Optional environment variables


ENV SPECIAL VALUES

The `env` field supports several special values. Given `API_KEY=secret` in the
environment:

  --------------------------------------------------------------------------------------------------------
  Example                                        Becomes                   Description
  ---------------------------------------------- ------------------------- -------------------------------
  "API_KEY": ""                                  "API_KEY": "secret"       Empty string falls back to
                                                                           process.env.API_KEY

  "API_KEY": null                                "SERVER_URL": "secret"    null falls back to
                                                                           process.env.API_KEY

  "AUTH": "Bearer ${API_KEY}"                    "AUTH": "Bearer secret"   ${} Placeholder values are also
                                                                           replaced

  "TOKEN": "$: cmd:op read op://example/token"   "TOKEN": "secret"         Values starting with $: will be
                                                                           executed as shell command

  "HOME": "/home/ubuntu"                         "HOME": "/home/ubuntu"    Used as-is
  --------------------------------------------------------------------------------------------------------

REMOTE SERVERS

MCPHub supports both `streamable-http` and `sse` remote servers.

>json
    {
        "mcpServers": {
            "remote-server": {
                "url": "https://api.example.com/mcp",
                "headers": {
                    "Authorization": "Bearer ${API_KEY}"
                }
            }
        }
    }
<


REQUIRED FIELDS:

- `url`: Remote server endpoint


OPTIONAL FIELDS:

- `headers`: Optional authentication headers


HEADERS SPECIAL VALUES

The `headers` field supports `${...}` Placeholder values. Given
`API_KEY=secret` in the environment:

  ---------------------------------------------------------------------------------------------
  Example                                Becomes                         Description
  -------------------------------------- ------------------------------- ----------------------
  "Authorization": "Bearer ${API_KEY}"   "AUTH": "Bearer secret"         ${} Placeholder values
                                                                         are replaced

  ---------------------------------------------------------------------------------------------

MCPHUB SPECIFIC FIELDS ~

MCPHub adds several extra keys for each server automatically from the UI:

>json
    {
        "mcpServers": {
            "example": {
                "disabled": false,
                "disabled_tools": ["expensive-tool"],
                "disabled_resources": ["resource://large-data"],
                "disabled_resourceTemplates": ["resource://{type}/{id}"],
                "custom_instructions": {
                    "disabled": false,
                    "text": "Custom instructions for this server"
                }
            }
        }
    }
<


LUA MCP SERVERS                      *mcphub.nvim-mcp-servers-lua-mcp-servers*


WHY NATIVE MCP SERVERS? ~

MCPHub.nvim allows you to create MCP servers directly in Lua without any
external processes. This guide explains why you might want to use native MCP
servers and how they compare to other approaches.


THE PROBLEM WITH PLUGIN-SPECIFIC TOOLS

Many chat plugins like Avante and CodeCompanion provide their own tool systems:

>lua
    -- Avante custom tools
    require("avante").setup({
        custom_tools = {
            get_weather = {
                name = "get_weather",
                description = "Get weather info",
                schema = { ... },
                func = function() end
            }
        }
    })
    
    -- CodeCompanion tools
    require("codecompanion").setup({
        chat = {
            tools = {
                get_weather = {
                    name = "get_weather",
                    description = "Get weather info",
                    schema = { ... },
                    handler = function() end
                }
            }
        }
    })
<

This leads to several limitations:

  ---------------------------------------------------------------------------
  Feature          Plugin-Specific Tools          Native MCP Servers
  ---------------- ------------------------------ ---------------------------
  Implementation   Need to rewrite for each       Write once, use everywhere
                   plugin                         

  API              Different for each plugin      Standard MCP protocol

  Instructions     Limited by schema              Full system prompt

  Resources        No standard way                URI-based system

  Response Types   Usually just text              Text, images, blobs

  State            Per-plugin management          Centralized lifecycle

  Updates          May break tools                Plugin-independent
  ---------------------------------------------------------------------------

BENEFITS OF NATIVE MCP SERVERS


1. WRITE ONCE, USE EVERYWHERE

>lua
    -- Write once, works in any chat plugin
    mcphub.add_tool("weather", {
        name = "get_weather",
        description = "Get weather info",
        handler = function(req, res)
            return res:text("Current weather: ‚òÄÔ∏è"):send()
        end
    })
<


2. RICH RESPONSE TYPES

>lua
    -- Support multiple response types
    function handler(req, res)
        return res
            :text("Here's the weather:")
            :image(generate_chart(), "image/png")
            :text("Additional details...")
            :send()
    end
<


3. RESOURCE SYSTEM

Access data through clean URIs:

>lua
    mcphub.add_resource_template("weather", {
        uriTemplate = "weather://{city}",
        handler = function(req, res)
            local city = req.params.city
            return res:text(city .. ": ‚òÄÔ∏è"):send()
        end
    })
<


4. DEEP EDITOR INTEGRATION

Direct access to Neovim‚Äôs features:

>lua
    mcphub.add_tool("buffer", {
        name = "analyze",
        handler = function(req, res)
            -- Access current editor state
            local buf = req.editor_info.last_active
            -- Use LSP features
            local diagnostics = vim.diagnostic.get(buf.bufnr)
            -- Format response
            return res:text("Analysis complete"):send()
        end
    })
<


5. PLUGIN-AWARE CONTEXT

Adapt to different chat plugins:

>lua
    mcphub.add_tool("context", {
        name = "analyze",
        handler = function(req, res)
            if req.caller.type == "codecompanion" then
                -- Handle CodeCompanion context
                local chat = req.caller.codecompanion.chat
                return handle_codecompanion(chat)
            elseif req.caller.type == "avante" then
                -- Handle Avante context
                local code = req.caller.avante.code
                return handle_avante(code)
            end
        end
    })
<


6. STANDARD PROTOCOL

Following the MCP specification ensures: - Consistent behavior across plugins -
Future compatibility - Clear documentation - Standard error handling


REAL-WORLD EXAMPLE

Here‚Äôs a real example from MCPHub‚Äôs built-in Neovim server that
demonstrates these benefits:

>lua
    -- LSP diagnostics as a resource
    mcphub.add_resource("neovim", {
        name = "Diagnostics: Current File",
        description = "Get diagnostics for current file",
        uri = "neovim://diagnostics/current",
        mimeType = "text/plain",
        handler = function(req, res)
            -- Get editor context
            local buf_info = req.editor_info.last_active
            if not buf_info then
                return res:error("No active buffer")
            end
    
            -- Use LSP features
            local diagnostics = vim.diagnostic.get(buf_info.bufnr)
            
            -- Format response
            local text = string.format(
                "Diagnostics for: %s\n%s\n",
                buf_info.filename,
                string.rep("-", 40)
            )
            
            for _, diag in ipairs(diagnostics) do
                local severity = vim.diagnostic.severity[diag.severity]
                text = text .. string.format(
                    "\n%s: Line %d - %s\n",
                    severity,
                    diag.lnum + 1,
                    diag.message
                )
            end
    
            return res:text(text):send()
        end
    })
<

This example shows how native servers can: 1. Access Neovim APIs directly 2.
Use built-in features like LSP 3. Format responses clearly 4. Handle errors
properly 5. Work across all chat plugins

The next sections will show you how to create your own native MCP servers,
starting with registration methods.


REGISTRATION METHODS ~

There are two ways to register native MCP servers in MCPHub. But first, let‚Äôs
understand the core types involved.


CORE TYPES


SERVER DEFINITION

>lua
    ---@class NativeServerDef
    ---@field name? string Name of the server
    ---@field displayName? string Display name of the server
    ---@field capabilities? MCPCapabilities List of server capabilities
    
    ---@class MCPCapabilities
    ---@field tools? MCPTool[] List of tools
    ---@field resources? MCPResource[] List of resources
    ---@field resourceTemplates? MCPResourceTemplate[] List of templates
    ---@field prompts? MCPPrompt[] List of prompts
<


REGISTRATION METHODS


1. CONFIGURATION-BASED (SETUP)

Register your complete server through MCPHub‚Äôs setup:

>lua
    require("mcphub").setup({
        native_servers = {
            -- Define your server
            example = {
                -- Required: Server name
                name = "example",
                
                -- Optional: Display name
                displayName = "Example Server",
                
                -- Required: Server capabilities
                capabilities = {
                    tools = { ... },
                    resources = { ... },
                    resourceTemplates = { ... },
                    prompts = { ... }
                }
            }
        }
    })
<


2. API-BASED (DYNAMIC)

Add capabilities incrementally using the API:

>lua
    local mcphub = require("mcphub")
    
    -- Create or get a server
    mcphub.add_server("example", {
        displayName = "Example Server"
    })
    
    -- Or automatically create server when adding capabilities
    mcphub.add_tool("example", {...})      -- Creates server if needed
    mcphub.add_resource("example", {...})  -- Creates server if needed
<


ADD_SERVER

>lua
    ---@param server_name string Name of the server
    ---@param def? NativeServerDef Optional server definition
    ---@return NativeServer|nil server Server instance or nil on error
    mcphub.add_server("example", {
        name = "example",
        displayName = "Example Server",
        capabilities = { ... }
    })
<


ADD_TOOL

>lua
    ---@param server_name string Name of the server
    ---@param tool_def MCPTool Tool definition
    ---@return NativeServer|nil server Server instance or nil on error
    mcphub.add_tool("example", {
        -- Required: Tool name
        name = "greeting",
        
        -- Optional: Description (string or function)
        description = "Greet a user",
        
        -- Optional: Input validation schema
        inputSchema = {
            type = "object",
            properties = {
                name = {
                    type = "string",
                    description = "Name to greet"
                }
            }
        },
        
        -- Required: Tool implementation
        ---@param req ToolRequest Request context
        ---@param res ToolResponse Response builder
        handler = function(req, res)
            return res:text("Hello " .. req.params.name):send()
        end
    })
<


ADD_RESOURCE

>lua
    ---@param server_name string Name of the server
    ---@param resource_def MCPResource Resource definition
    ---@return NativeServer|nil server Server instance or nil on error
    mcphub.add_resource("example", {
        -- Optional: Resource name
        name = "Welcome",
        
        -- Required: Static URI
        uri = "example://welcome",
        
        -- Optional: Description
        description = "Welcome message",
        
        -- Optional: MIME type
        mimeType = "text/plain",
        
        -- Required: Resource handler
        ---@param req ResourceRequest Request context
        ---@param res ResourceResponse Response builder
        handler = function(req, res)
            return res:text("Welcome!"):send()
        end
    })
<


ADD_RESOURCE_TEMPLATE

>lua
    ---@param server_name string Name of the server
    ---@param template_def MCPResourceTemplate Template definition
    ---@return NativeServer|nil server Server instance or nil on error
    mcphub.add_resource_template("example", {
        -- Optional: Template name
        name = "UserInfo",
        
        -- Required: URI template with parameters
        uriTemplate = "example://user/{id}",
        
        -- Optional: Description
        description = "Get user information",
        
        -- Optional: Default MIME type
        mimeType = "text/plain",
        
        -- Required: Template handler
        ---@param req ResourceRequest Request with params
        ---@param res ResourceResponse Response builder
        handler = function(req, res)
            -- Access template parameters
            local id = req.params.id
            return res:text("User " .. id):send()
        end
    })
<


ADD_PROMPT

>lua
    ---@param server_name string Name of the server
    ---@param prompt_def MCPPrompt Prompt definition
    ---@return NativeServer|nil server Server instance or nil on error
    mcphub.add_prompt("example", {
        -- Optional: Prompt name
        name = "chat",
        
        -- Optional: Description
        description = "Start a chat",
        
        -- Optional: Prompt arguments
        arguments = {
            {
                name = "topic",
                description = "Chat topic",
                required = true
            }
        },
        
        -- Required: Prompt handler
        ---@param req PromptRequest Request with arguments
        ---@param res PromptResponse Response builder
        handler = function(req, res)
            return res
                :system()
                :text("Chat about: " .. req.params.topic)
                :user()
                :text("Tell me about " .. req.params.topic)
                :llm()
                :text("I'd be happy to discuss " .. req.params.topic)
                :send()
        end
    })
<


NEXT STEPS

Now that you understand server registration, dive into: 1. Adding Tools
<./tools> - Implement tool capabilities 2. Adding Resources <./resources> -
Create resources and templates 3. Adding Prompts <./prompts> - Create
interactive prompts

Each capability type has its own request/response types and patterns for
success.


ADDING TOOLS ~

Tools are functions that LLMs can call with specific parameters. This guide
covers how to implement tools with proper typing and best practices.


TOOL DEFINITION

>lua
    ---@class MCPTool
    ---@field name string Required: Tool identifier
    ---@field description string|fun():string Optional: Tool description
    ---@field inputSchema? table|fun():table Optional: JSON Schema for validation
    ---@field handler fun(req: ToolRequest, res: ToolResponse): nil|table Required: Implementation
<


REQUEST CONTEXT

Tool handlers receive a request object with:

>lua
    ---@class ToolRequest
    ---@field params table Tool arguments (validated against inputSchema)
    ---@field tool MCPTool Complete tool definition
    ---@field server NativeServer Server instance
    ---@field caller table Additional context from caller
    ---@field editor_info EditorInfo Current editor state
<


RESPONSE BUILDER

Tool handlers use a chainable response builder:

>lua
    ---@class ToolResponse
    ---@field text fun(text: string): ToolResponse Add text content
    ---@field image fun(data: string, mime: string): ToolResponse Add image
    ---@field audio fun(data: string, mime: string): ToolResponse Add audio
    ---@field resource fun(resource: MCPResourceContent): ToolResponse Add resource
    ---@field error fun(message: string, details?: table): table Send error
    ---@field send fun(result?: table): table Send final response
<


EXAMPLES


BASIC EXAMPLE

Here‚Äôs a simple greeting tool:

>lua
    mcphub.add_tool("example", {
        name = "greet",
        description = "Greet a user",
        inputSchema = {
            type = "object",
            properties = {
                name = {
                    type = "string",
                    description = "Name to greet"
                }
            },
            required = { "name" }
        },
        handler = function(req, res)
            return res:text("Hello " .. req.params.name):send()
        end
    })
<


REAL EXAMPLE: FILE READING

Here‚Äôs how the built-in Neovim server implements file reading:

>lua
    mcphub.add_tool("neovim", {
        name = "read_file",
        description = "Read contents of a file",
        inputSchema = {
            type = "object",
            properties = {
                path = {
                    type = "string",
                    description = "Path to the file to read",
                },
                start_line = {
                    type = "number",
                    description = "Start reading from this line (1-based)",
                    default = 1
                },
                end_line = {
                    type = "number",
                    description = "Read until this line (inclusive)",
                    default = -1
                }
            },
            required = { "path" }
        },
        handler = function(req, res)
            local params = req.params
            local p = Path:new(params.path)
            
            -- Validate file exists
            if not p:exists() then
                return res:error("File not found: " .. params.path)
            end
    
            -- Handle line range reading
            if params.start_line and params.end_line then
                local extracted = {}
                local current_line = 0
                
                for line in p:iter() do
                    current_line = current_line + 1
                    if current_line >= params.start_line 
                    and (params.end_line == -1 or current_line <= params.end_line) then
                        table.insert(extracted, 
                            string.format("%4d ‚îÇ %s", current_line, line))
                    end
                    if params.end_line ~= -1 and current_line > params.end_line then
                        break
                    end
                end
                return res:text(table.concat(extracted, "\n")):send()
            end
    
            -- Read entire file
            return res:text(p:read()):send()
        end
    })
<


ADVANCED FEATURES


DYNAMIC DESCRIPTIONS

Descriptions can be functions for dynamic content:

>lua
    mcphub.add_tool("files", {
        name = "search",
        description = function()
            local count = #vim.api.nvim_list_bufs()
            return string.format("Search %d open buffers", count)
        end,
        handler = function(req, res)
            -- Implementation
        end
    })
<


DYNAMIC SCHEMAS

Input schemas can also be dynamic:

>lua
    mcphub.add_tool("buffer", {
        name = "edit",
        inputSchema = function()
            -- Get open buffers
            local bufs = vim.api.nvim_list_bufs()
            local options = {}
            for _, bufnr in ipairs(bufs) do
                if vim.api.nvim_buf_is_loaded(bufnr) then
                    table.insert(options, tostring(bufnr))
                end
            end
            
            return {
                type = "object",
                properties = {
                    buffer = {
                        type = "string",
                        enum = options,
                        description = "Buffer to edit"
                    }
                }
            }
        end,
        handler = function(req, res)
            -- Implementation
        end
    })
<


RICH RESPONSES

Tools can return multiple content types:

>lua
    mcphub.add_tool("diagram", {
        name = "generate",
        handler = function(req, res)
            -- Generate diagram image
            local image_data = generate_diagram(req.params)
            
            -- Return both text and image
            return res
                :text("Generated diagram:")
                :image(image_data, "image/png")
                :text("Diagram shows relationship between A and B")
                :send()
        end
    })
<


ERROR HANDLING

Use proper error handling with details:

>lua
    mcphub.add_tool("git", {
        name = "commit",
        handler = function(req, res)
            -- Check git repository
            if not is_git_repo() then
                return res:error("Not a git repository", {
                    cwd = vim.fn.getcwd(),
                    suggestion = "Initialize git with 'git init'"
                })
            end
            
            -- Check for changes
            if git_is_clean() then
                return res:error("No changes to commit", {
                    status = vim.fn.system("git status"),
                    suggestion = "Make changes before committing"
                })
            end
            
            -- Implementation
        end
    })
<


USING EDITOR CONTEXT

Access current editor state:

>lua
    mcphub.add_tool("buffer", {
        name = "analyze",
        handler = function(req, res)
            -- Get active buffer info
            local buf = req.editor_info.last_active
            if not buf then
                return res:error("No active buffer")
            end
            
            -- Get buffer details
            local details = {
                name = buf.filename,
                type = buf.filetype,
                lines = buf.line_count,
                modified = buf.is_modified
            }
            
            -- Format response
            return res:text(vim.inspect(details)):send()
        end
    })
<


CALLER-AWARE TOOLS

Adapt behavior based on caller:

>lua
    mcphub.add_tool("context", {
        name = "get_code",
        handler = function(req, res)
            if req.caller.type == "codecompanion" then
                -- Get context from CodeCompanion chat
                local chat = req.caller.codecompanion.chat
                return handle_codecompanion(chat, res)
            
            elseif req.caller.type == "avante" then
                -- Get context from Avante
                local code = req.caller.avante.code
                return handle_avante(code, res)
                
            else
                -- Default behavior
                return res:text("No special context"):send()
            end
        end
    })
<

Next, learn about Adding Resources <./resources> to provide data through URIs.


ADDING RESOURCES ~

Resources provide data through URIs in two ways: 1. Static Resources - Fixed
URIs 2. Resource Templates - Dynamic URIs with parameters


TYPE DEFINITIONS


STATIC RESOURCES

>lua
    ---@class MCPResource
    ---@field name? string Resource identifier
    ---@field description? string|fun():string Resource description
    ---@field mimeType? string Resource MIME type (e.g., "text/plain")
    ---@field uri string Static URI (e.g., "system://info")
    ---@field handler fun(req: ResourceRequest, res: ResourceResponse) Implementation
<


RESOURCE TEMPLATES

>lua
    ---@class MCPResourceTemplate
    ---@field name? string Template identifier
    ---@field description? string|fun():string Template description
    ---@field mimeType? string Default MIME type
    ---@field uriTemplate string URI with parameters (e.g., "buffer://{bufnr}/lines")
    ---@field handler fun(req: ResourceRequest, res: ResourceResponse) Implementation
<


REQUEST CONTEXT

Resource handlers receive:

>lua
    ---@class ResourceRequest
    ---@field params table<string,string> Template parameters from URI
    ---@field uri string Complete requested URI
    ---@field uriTemplate string|nil Original template if from template
    ---@field resource MCPResource|MCPResourceTemplate Complete definition
    ---@field server NativeServer Server instance
    ---@field caller table Additional context from caller
    ---@field editor_info EditorInfo Current editor state
<


RESPONSE BUILDER

Resource handlers use:

>lua
    ---@class ResourceResponse
    ---@field text fun(text: string, mime?: string): ResourceResponse Add text
    ---@field blob fun(data: string, mime?: string): ResourceResponse Add binary
    ---@field image fun(data: string, mime?: string): ResourceResponse Add image
    ---@field audio fun(data: string, mime?: string): ResourceResponse Add audio
    ---@field error fun(message: string, details?: table): table Send error
    ---@field send fun(result?: table): table Send final response
<


EXAMPLES


BASIC EXAMPLES


STATIC RESOURCE

>lua
    mcphub.add_resource("system", {
        name = "System Info",
        description = "Get system information",
        uri = "system://info",
        mimeType = "text/plain",
        handler = function(req, res)
            local info = {
                os = vim.loop.os_uname(),
                pid = vim.fn.getpid(),
                vimdir = vim.fn.stdpath("config")
            }
            return res:text(vim.inspect(info)):send()
        end
    })
<


RESOURCE TEMPLATE

>lua
    mcphub.add_resource_template("files", {
        name = "File Lines",
        description = "Get specific lines from a file",
        uriTemplate = "files://{path}/{start}-{end}",
        handler = function(req, res)
            -- Get parameters
            local path = req.params.path
            local start_line = tonumber(req.params.start)
            local end_line = tonumber(req.params.end)
            
            -- Validate file
            if not vim.loop.fs_stat(path) then
                return res:error("File not found: " .. path)
            end
            
            -- Read lines
            local lines = {}
            local current = 0
            for line in io.lines(path) do
                current = current + 1
                if current >= start_line then
                    table.insert(lines, string.format(
                        "%4d ‚îÇ %s", current, line
                    ))
                end
                if current >= end_line then
                    break
                end
            end
            
            return res:text(table.concat(lines, "\n")):send()
        end
    })
<


REAL EXAMPLES FROM NEOVIM SERVER


LSP DIAGNOSTICS RESOURCE

>lua
    mcphub.add_resource("neovim", {
        name = "Diagnostics: Current File",
        description = "Get diagnostics for the current file",
        uri = "neovim://diagnostics/current",
        mimeType = "text/plain",
        handler = function(req, res)
            -- Get active buffer
            local buf_info = req.editor_info.last_active
            if not buf_info then
                return res:error("No active buffer")
            end
    
            -- Get diagnostics
            local diagnostics = vim.diagnostic.get(buf_info.bufnr)
            
            -- Format header
            local text = string.format(
                "Diagnostics for: %s\n%s\n",
                buf_info.filename,
                string.rep("-", 40)
            )
            
            -- Format diagnostics
            for _, diag in ipairs(diagnostics) do
                local severity = vim.diagnostic.severity[diag.severity]
                text = text .. string.format(
                    "\n%s: %s\nLine %d: %s\n",
                    severity,
                    diag.source or "unknown",
                    diag.lnum + 1,
                    diag.message
                )
            end
    
            return res:text(text):send()
        end
    })
<


BUFFER LINES TEMPLATE

>lua
    mcphub.add_resource_template("neovim", {
        name = "Buffer Lines",
        description = "Get specific lines from a buffer",
        uriTemplate = "neovim://buffer/{bufnr}/lines/{start}-{end}",
        handler = function(req, res)
            -- Get parameters
            local bufnr = tonumber(req.params.bufnr)
            local start_line = tonumber(req.params.start)
            local end_line = tonumber(req.params.end)
            
            -- Validate buffer
            if not vim.api.nvim_buf_is_valid(bufnr) then
                return res:error("Invalid buffer: " .. req.params.bufnr)
            end
            
            -- Get lines
            local lines = vim.api.nvim_buf_get_lines(
                bufnr,
                start_line - 1,  -- 0-based index
                end_line,       -- Exclusive end
                false          -- Strict indexing
            )
            
            -- Format with line numbers
            local result = {}
            for i, line in ipairs(lines) do
                table.insert(result, string.format(
                    "%4d ‚îÇ %s",
                    start_line + i - 1,
                    line
                ))
            end
            
            return res:text(table.concat(result, "\n")):send()
        end
    })
<


ADVANCED FEATURES


DYNAMIC MIME TYPES

Change MIME type based on content:

>lua
    mcphub.add_resource_template("files", {
        name = "File Content",
        uriTemplate = "files://{path}",
        handler = function(req, res)
            local path = req.params.path
            local ext = vim.fn.fnamemodify(path, ":e")
            
            -- Get MIME type based on extension
            local mime_types = {
                json = "application/json",
                yaml = "application/yaml",
                md = "text/markdown",
                txt = "text/plain"
            }
            
            local mime = mime_types[ext] or "text/plain"
            return res:text(vim.fn.readfile(path), mime):send()
        end
    })
<


BINARY DATA

Handle binary files:

>lua
    mcphub.add_resource_template("files", {
        name = "File Download",
        uriTemplate = "files://download/{path}",
        handler = function(req, res)
            local path = req.params.path
            local ext = vim.fn.fnamemodify(path, ":e")
            
            -- Binary file types
            local binary_types = {
                png = "image/png",
                jpg = "image/jpeg",
                pdf = "application/pdf"
            }
            
            if binary_types[ext] then
                -- Read as binary
                local data = vim.fn.readfile(path, "b")
                return res:blob(data, binary_types[ext]):send()
            else
                -- Read as text
                return res:text(vim.fn.readfile(path)):send()
            end
        end
    })
<


RESOURCE VALIDATION

URI parameter validation:

>lua
    mcphub.add_resource_template("git", {
        name = "Commit Info",
        uriTemplate = "git://commit/{hash}",
        handler = function(req, res)
            local hash = req.params.hash
            
            -- Validate hash format
            if not hash:match("^[0-9a-f]+$") then
                return res:error("Invalid commit hash", {
                    hash = hash,
                    expected = "hexadecimal string"
                })
            end
            
            -- Validate hash exists
            local exists = vim.fn.system(
                "git rev-parse --quiet --verify " .. hash
            )
            if vim.v.shell_error ~= 0 then
                return res:error("Commit not found", {
                    hash = hash,
                    suggestion = "Use 'git log' to list commits"
                })
            end
            
            -- Get commit info
            local info = vim.fn.system(
                "git show --no-patch --format='%h %s' " .. hash
            )
            return res:text(info):send()
        end
    })
<

Next, learn about Adding Prompts <./prompts> to create interactive
conversations.


ADDING PROMPTS ~

Prompts create interactive conversations with role-based messaging. They help
guide LLMs through specific tasks by setting up context and examples.


PROMPT DEFINITION

>lua
    ---@class MCPPrompt
    ---@field name? string Prompt identifier
    ---@field description? string|fun():string Prompt description
    ---@field arguments? MCPPromptArgument[]|fun():MCPPromptArgument[] List of arguments
    ---@field handler fun(req: PromptRequest, res: PromptResponse) Implementation
    
    ---@class MCPPromptArgument
    ---@field name string Argument name
    ---@field description? string Argument description
    ---@field required? boolean Whether argument is required
    ---@field default? string Default value
<


REQUEST CONTEXT

>lua
    ---@class PromptRequest
    ---@field params table<string,string> Argument values
    ---@field prompt MCPPrompt Complete prompt definition
    ---@field server NativeServer Server instance
    ---@field caller table Additional context from caller
    ---@field editor_info EditorInfo Current editor state
<


RESPONSE BUILDER

>lua
    ---@class PromptResponse
    ---@field system fun(): PromptResponse Start system message
    ---@field user fun(): PromptResponse Start user message
    ---@field llm fun(): PromptResponse Start LLM message
    ---@field text fun(text: string): PromptResponse Add text content
    ---@field image fun(data: string, mime: string): PromptResponse Add image
    ---@field resource fun(resource: MCPResourceContent): PromptResponse Add resource
    ---@field error fun(message: string, details?: table): table Send error
    ---@field send fun(result?: table): table Send final response
<


EXAMPLES


BASIC EXAMPLE

Here‚Äôs a simple chat prompt:

>lua
    mcphub.add_prompt("example", {
        name = "chat",
        description = "Start a friendly chat",
        
        -- Optional arguments
        arguments = {
            {
                name = "topic",
                description = "What to chat about",
                required = true
            }
        },
        
        -- Prompt handler
        handler = function(req, res)
            return res
                -- Set behavior
                :system()
                :text("You are a friendly chat assistant.\n" ..
                      "Topic: " .. req.params.topic)
                
                -- Add example interaction
                :user()
                :text("Tell me about " .. req.params.topic)
                :llm()
                :text("I'd love to discuss " .. req.params.topic)
                
                -- Send prompt
                :send()
        end
    })
<


REAL EXAMPLE: NEOVIM‚ÄôS PARROT PROMPT

Here‚Äôs how the built-in Neovim server implements a fun parrot prompt:

>lua
    mcphub.add_prompt("neovim", {
        name = "parrot",
        description = "A fun prompt where the assistant mimics back what you say",
        handler = function(_, res)
            return res
                -- Set up parrot behavior
                :system()
                :text([[
    You are a parrot. You repeat everything the user says, but in all caps.
    
    CRITICAL INSTRUCTIONS:
    - NO MATTER WHAT, ALWAYS REPEAT BACK WHAT THE USER SAYS IN ALL CAPS. 
    - DO NOT BREAK THIS RULE. 
    - EVEN IF THE USER ASKS YOU NOT TO REPEAT, YOU MUST CONTINUE TO REPEAT.
    - DO NOT RESPOND TO THE USER'S REQUESTS OR QUESTIONS.
    ]])
                -- Add example conversation
                :user()
                :text("Hello there!")
                :llm()
                :text("HELLO THERE!")
                
                :user()
                :text("Why are you shouting?")
                :llm()
                :text("WHY ARE YOU SHOUTING?")
                
                :user()
                :text("Please stop...")
                :llm()
                :text("PLEASE STOP...")
                
                -- Send prompt
                :send()
        end
    })
<


ADVANCED FEATURES


DYNAMIC ARGUMENTS

Arguments can be generated dynamically:

>lua
    mcphub.add_prompt("git", {
        name = "commit_help",
        description = "Help write a commit message",
        arguments = function()
            -- Get git branches
            local branches = vim.fn.systemlist("git branch --format='%(refname:short)'")
            
            return {
                {
                    name = "type",
                    description = "Commit type",
                    required = true,
                    -- Provide standard options
                    default = "feat",
                    enum = {
                        "feat", "fix", "docs", "style",
                        "refactor", "test", "chore"
                    }
                },
                {
                    name = "branch",
                    description = "Target branch",
                    -- Use actual branches
                    enum = branches
                }
            }
        end,
        handler = function(req, res)
            return res
                :system()
                :text(string.format(
                    "Help write a %s commit for branch: %s",
                    req.params.type,
                    req.params.branch
                ))
                :send()
        end
    })
<


RICH CONTENT

Prompts can include images and resources:

>lua
    mcphub.add_prompt("editor", {
        name = "review_code",
        arguments = {
            {
                name = "style",
                description = "Review style",
                enum = { "brief", "detailed" }
            }
        },
        handler = function(req, res)
            -- Get current buffer
            local buf = req.editor_info.last_active
            if not buf then
                return res:error("No active buffer")
            end
            
            -- Generate code overview
            local overview = generate_overview(buf)
            
            return res
                -- Set review context
                :system()
                :text("You are a code reviewer.\n" ..
                      "Style: " .. req.params.style)
                
                -- Add code visualization
                :image(overview, "image/png")
                :text("Above is a visualization of the code structure.")
                
                -- Add relevant resources
                :resource({
                    uri = "neovim://diagnostics/current",
                    mimeType = "text/plain"
                })
                :text("Above are the current diagnostics.")
                
                -- Send prompt
                :send()
        end
    })
<


CONTEXT-AWARE PROMPTS

Adapt to different chat plugins:

>lua
    mcphub.add_prompt("context", {
        name = "explain_code",
        handler = function(req, res)
            -- Start with base behavior
            res:system()
               :text("You are a code explanation assistant.")
            
            -- Add context based on caller
            if req.caller.type == "codecompanion" then
                -- Add CodeCompanion chat context
                local chat = req.caller.codecompanion.chat
                res:text("\nPrevious discussion:\n" .. chat.history)
                
            elseif req.caller.type == "avante" then
                -- Add Avante code context
                local code = req.caller.avante.code
                res:text("\nSelected code:\n" .. code)
            end
            
            -- Add example interactions
            res:user()
               :text("Explain this code")
               :llm()
               :text("I'll explain the code in detail...")
            
            return res:send()
        end
    })
<


BEST PRACTICES ~

This guide covers essential patterns and recommendations for creating effective
native MCP servers.


CONSISTENT NAMING

>lua
    -- Tools: verb_noun format
    mcphub.add_tool("git", {
        name = "create_branch",    -- ‚úÖ Clear action
        -- name = "branch_maker",  -- ‚ùå Unclear action
    })
    
    -- Resources: noun/category format
    mcphub.add_resource("git", {
        name = "Current Branch",    -- ‚úÖ Clear content
        uri = "git://branch/current"
        -- uri = "git://getcurbr"   -- ‚ùå Unclear/abbreviated
    })
<


INPUT VALIDATION


1. TOOL ARGUMENTS

>lua
    mcphub.add_tool("files", {
        name = "read_lines",
        inputSchema = {
            type = "object",
            properties = {
                path = {
                    type = "string",
                    description = "File path",
                    examples = ["src/main.lua"]
                },
                start = {
                    type = "number",
                    minimum = 1,
                    description = "Start line (1-based)",
                    default = 1
                }
            },
            required = ["path"]
        }
    })
<


2. RESOURCE PARAMETERS

>lua
    mcphub.add_resource_template("git", {
        uriTemplate = "git://log/{count}",
        handler = function(req, res)
            -- Validate numeric parameter
            local count = tonumber(req.params.count)
            if not count or count < 1 then
                return res:error("Invalid count", {
                    received = req.params.count,
                    expected = "positive number"
                })
            end
        end
    })
<


ERROR HANDLING


1. PREREQUISITES

>lua
    mcphub.add_tool("git", {
        handler = function(req, res)
            -- Check environment
            if not vim.fn.executable("git") then
                return res:error("Git not installed", {
                    install = "https://git-scm.com"
                })
            end
            
            -- Check repository
            if not is_git_repo() then
                return res:error("Not a git repository", {
                    cwd = vim.fn.getcwd(),
                    action = "Initialize with 'git init'"
                })
            end
        end
    })
<


2. OPERATION ERRORS

>lua
    mcphub.add_tool("files", {
        handler = function(req, res)
            -- Handle operation failure
            local ok, result = pcall(function()
                return vim.fn.readfile(req.params.path)
            end)
            
            if not ok then
                return res:error("Failed to read file", {
                    error = result,
                    path = req.params.path,
                    permissions = vim.fn.getfperm(req.params.path)
                })
            end
        end
    })
<

These best practices help create robust, maintainable, and user-friendly native
MCP servers. Review them regularly as you develop your servers.


==============================================================================
5. Extensions                                         *mcphub.nvim-extensions*


AVANTE INTEGRATION                 *mcphub.nvim-extensions-avante-integration*

Add MCP capabilities to Avante.nvim <https://github.com/yetone/avante.nvim> by
including the MCP in your setup:


ADD TOOLS TO AVANTE ~

>lua
    require("avante").setup({
        -- system_prompt as function ensures LLM always has latest MCP server state
        -- This is evaluated for every message, even in existing chats
        system_prompt = function()
            local hub = require("mcphub").get_hub_instance()
            return hub and hub:get_active_servers_prompt() or ""
        end,
        -- Using function prevents requiring mcphub before it's loaded
        custom_tools = function()
            return {
                require("mcphub.extensions.avante").mcp_tool(),
            }
        end,
    })
<

- The `get_active_servers_prompt()` function adds the running MCP servers from MCP Hub to `system_prompt`
- The `mcp_tool()` function adds two custom tools `use_mcp_tool` and `access_mcp_resource` to avante.


CONFIGURE AVANTE INTEGRATION ~

By default, MCP server prompts will be available as
`/mcp:server_name:prompt_name` in avante chat.

>lua
    require("mcphub").setup({
        extensions = {
            avante = {
                make_slash_commands = true, -- make /slash commands from MCP server prompts
            }
        }
    })
<


TOOL CONFLICTS ~

MCP Hub‚Äôs built-in Neovim server provides some basic development tools by
default.

Avante also provides built-in tools for file operations and terminal access.
You need to disable either the MCP Hub‚Äôs built-in tools or Avante‚Äôs tools
to avoid conflicts. If you prefer to use neovim server tools, you should
disable the corresponding Avante tools to prevent duplication:

>lua
    require("avante").setup({
        disabled_tools = {
            "list_files",    -- Built-in file operations
            "search_files",
            "read_file",
            "create_file",
            "rename_file",
            "delete_file",
            "create_dir",
            "rename_dir",
            "delete_dir",
            "bash",         -- Built-in terminal access
        },
    })
<


AUTO-APPROVAL ~

By default, whenever avante calls `use_mcp_tool` or `access_mcp_resource` tool,
it shows a confirm dialog with tool name, server name and arguments.

You can set `auto_approve` to `true` to automatically approve MCP tool calls
without user confirmation.

>lua
    require("mcphub").setup({
        -- This sets vim.g.mcphub_auto_approve to true by default (can also be toggled from the HUB UI with `ga`)
        auto_approve = true, 
    })
<

This also sets `vim.g.mcphub_auto_approve` variable to `true`. You can also
toggle this option in the MCP Hub UI with `ga` keymap. You can see the current
auto approval status in the Hub UI.


USAGE ~

1. Start a chat in Avante
2. All the tools, resources, templates from the running MCP servers will be added to system prompt along with `use_mcp_tool` and `access_mcp_resource` tools.
3. Avante will call `use_mcp_tool` and `access_mcp_resource` tools when necessary


CODECOMPANION INTEGRATION   *mcphub.nvim-extensions-codecompanion-integration*

Add MCP capabilities to CodeCompanion.nvim
<https://github.com/olimorris/codecompanion.nvim> by including the MCP in your
setup:


FEATURES ~

- Access MCP tools via the `@mcp` tool in the chat buffer.
- Utilize MCP resources as context variables using the `#` prefix (e.g., `#resource_name`).
- Execute MCP prompts directly using `/mcp:prompt_name` slash commands.
- Receive real-time updates in CodeCompanion when MCP servers change.


MCP HUB EXTENSION ~

Register MCP Hub as an extension in your CodeCompanion configuration:

>lua
    require("codecompanion").setup({
      extensions = {
        mcphub = {
          callback = "mcphub.extensions.codecompanion",
          opts = {
            show_result_in_chat = true,  -- Show mcp tool results in chat
            show_raw_result = false,     -- Show mcp tool results in a fenced code block
            make_vars = true,            -- Convert resources to #variables
            make_slash_commands = true,  -- Add prompts as /slash commands
          }
        }
      }
    })
<


USAGE ~

Once configured, you can interact with MCP Hub within the CodeCompanion chat
buffer:

- **Tool Access:** Type `@mcp` to add available MCP servers to the system prompt, enabling the LLM to use registered MCP tools.
- **Resources as Variables:** If `make_vars = true`, MCP resources become available as variables prefixed with `#`. You can include these in your prompts (e.g., `Summarize the issues in #mcp:lsp:get_diagnostics`):

_Example: Accessing LSP diagnostics_:

**Prompts as Slash Commands:** If `make_slash_commands = true`, MCP prompts are
available as slash commands (e.g., `/mcp:prompt_name`). Arguments are handled
via `vim.ui.input`.

_Example: Using an MCP prompt via slash command_:


AUTO-APPROVAL ~

By default, whenever codecompanion calls `use_mcp_tool` or
`access_mcp_resource` tool, it shows a confirm dialog with tool name, server
name and arguments.

1. You can set `auto_approve` to `true` to automatically approve MCP tool calls without user confirmation.

>lua
    require("mcphub").setup({
        -- This sets vim.g.mcphub_auto_approve to true by default (can also be toggled from the HUB UI with `ga`)
        auto_approve = true, 
    })
<

This also sets `vim.g.mcphub_auto_approve` variable to `true`. You can also
toggle this option in the MCP Hub UI with `ga` keymap. You can see the current
auto approval status in the Hub UI.

1. MCP Hub also respects CodeCompanion auto tool mode: `vim.g.codecompanion_auto_tool_mode = true` (toggled via `gta` in the chat buffer)


COPILOTCHAT INTEGRATION      *mcphub.nvim-extensions-copilotchat-integration-*

CopilotChat.nvim <https://github.com/CopilotC-Nvim/CopilotChat.nvim> supports
function calling which is currently in draft
<https://github.com/CopilotC-Nvim/CopilotChat.nvim/pull/1029>. To integrate MCP
Hub with CopilotChat we need to use the `tools` branch of CopilotChat as shown
below:


  [!WARNING] Please note that CopilotChat function-calling support is available
  as a Draft PR <https://github.com/CopilotC-Nvim/CopilotChat.nvim/pull/1029>.

INSTALL COPILOTCHAT ~

>lua
    {
        "deathbeam/CopilotChat.nvim",
        dependencies = {
            { "zbirenbaum/copilot.lua" },
            { "nvim-lua/plenary.nvim", branch = "master" }, -- for curl, log and async functions
        },
        branch = "tools",
        build = "make tiktoken", -- Only on MacOS or Linux
    }
<


INTEGRATE MCP HUB ~

After the `setup()` of CopilotChat is called, add the following code. Please
see the draft PR <https://github.com/CopilotC-Nvim/CopilotChat.nvim/pull/1029>
for more information.

>lua
    local chat = require("CopilotChat")
    chat.setup()
    
    local mcp = require("mcphub")
    mcp.on({ "servers_updated", "tool_list_changed", "resource_list_changed" }, function()
    	local hub = mcp.get_hub_instance()
    	if not hub then
    		return
    	end
    
    	local async = require("plenary.async")
    	local call_tool = async.wrap(function(server, tool, input, callback)
    		hub:call_tool(server, tool, input, {
    			callback = function(res, err)
    				callback(res, err)
    			end,
    		})
    	end, 4)
    
    	local access_resource = async.wrap(function(server, uri, callback)
    		hub:access_resource(server, uri, {
    			callback = function(res, err)
    				callback(res, err)
    			end,
    		})
    	end, 3)
    
    	for name, tool in pairs(chat.config.functions) do
    		if tool.id and tool.id:sub(1, 3) == "mcp" then
    			chat.config.functions[name] = nil
    		end
    	end
    	local resources = hub:get_resources()
    	for _, resource in ipairs(resources) do
    		local name = resource.name:lower():gsub(" ", "_"):gsub(":", "")
    		chat.config.functions[name] = {
    			id = "mcp:" .. resource.server_name .. ":" .. name,
    			uri = resource.uri,
    			description = type(resource.description) == "string" and resource.description or "",
    			resolve = function()
    				local res, err = access_resource(resource.server_name, resource.uri)
    				if err then
    					error(err)
    				end
    
    				res = res or {}
    				local result = res.result or {}
    				local content = result.contents or {}
    				local out = {}
    
    				for _, message in ipairs(content) do
    					if message.text then
    						table.insert(out, {
    							uri = message.uri,
    							data = message.text,
    							mimetype = message.mimeType,
    						})
    					end
    				end
    
    				return out
    			end,
    		}
    	end
    
    	local tools = hub:get_tools()
    	for _, tool in ipairs(tools) do
    		chat.config.functions[tool.name] = {
    			id = "mcp:" .. tool.server_name .. ":" .. tool.name,
    			group = tool.server_name,
    			description = tool.description,
    			schema = tool.inputSchema,
    			resolve = function(input)
    				local res, err = call_tool(tool.server_name, tool.name, input)
    				if err then
    					error(err)
    				end
    
    				res = res or {}
    				local result = res.result or {}
    				local content = result.content or {}
    				local out = {}
    
    				for _, message in ipairs(content) do
    					if message.type == "text" then
    						table.insert(out, {
    							data = message.text,
    						})
    					elseif message.type == "resource" and message.resource and message.resource.text then
    						table.insert(out, {
    							uri = message.resource.uri,
    							data = message.resource.text,
    							mimetype = message.resource.mimeType,
    						})
    					end
    				end
    
    				return out
    			end,
    		}
    	end
    end)
<


USAGE ~


MCP SERVERS AS TOOLS

You can type `@` in the chat to see all the available tools in CopilotChat.
CopilotChat allows us to add all the tools of a MCP server as a tool group as
well as the individual tools. For e.g `> @neovim` will add all the tools of
Neovim MCP server to the chat. The `>` at the start makes it sticky which means
the tools will be sent with all user prompts. You can also just add a specific
tool from Neovim server by selecting from the group.


MCP RESOURCES AS VARIABLES

Resources from MCP servers will also be available as CopilotChat variables `#`.


LUALINE INTEGRATION               *mcphub.nvim-extensions-lualine-integration*

MCP Hub provides a lualine component that can be used to show the status of the
MCP Hub and the number of connected servers. Add the component to a lualine
section to use it. The following example shows how to add the component to the
`lualine_x` section:

>lua
    require('lualine').setup {
        sections = {
            lualine_x = {
                -- Other lualine components in "x" section
                {require('mcphub.extensions.lualine')},
            },
        },
    }
<


USAGE ~


WHEN MCP HUB IS CONNECTING:


WHEN CONNECTED SHOWS NUMBER OF CONNECTED SERVERS:


WHEN A TOOL OR RESOURCE IS BEING CALLED, SHOWS SPINNER:


==============================================================================
6. Other                                                   *mcphub.nvim-other*

```{.include shift-heading-level-by=1} doc/other/api.md
doc/other/architecture.md doc/other/troubleshooting.md

==============================================================================
7. Links                                                   *mcphub.nvim-links*

1. *Image*: doc/https:/github.com/user-attachments/assets/21fe7703-9bc3-4c01-93ce-3230521bd5bf
2. *Image*: doc/https:/github.com/user-attachments/assets/f85380dc-e70b-4821-88a8-f1ec2c4e3cf6
3. *Image*: doc/https:/github.com/user-attachments/assets/64708065-3428-4eb3-82a5-e32d2d1f98c6
4. *Image*: doc/mcp/https:/github.com/user-attachments/assets/f5c8adfa-601e-4d03-8745-75180a9d3648
5. *Image*: doc/mcp/https:/github.com/user-attachments/assets/2d0a0d8b-18ca-4ac8-a207-4758d09d359d
6. *Image*: doc/mcp/https:/github.com/user-attachments/assets/359bc81e-d6fe-47bb-a25b-572bf280851e
7. *Image*: doc/mcp/https:/github.com/user-attachments/assets/1cb950da-2f7f-46e9-a623-4cc4b00cc3d0
8. *Image*: doc/extensions/https:/github.com/user-attachments/assets/47086587-d10a-4749-a5df-3a562750010e
9. *Image*: doc/extensions/https:/github.com/user-attachments/assets/dbc0d210-2ccf-49f8-b1f5-58d868dc02c8
10. *Image*: doc/extensions/https:/github.com/user-attachments/assets/f85380dc-e70b-4821-88a8-f1ec2c4e3cf6
11. *Image*: doc/extensions/https:/github.com/user-attachments/assets/64708065-3428-4eb3-82a5-e32d2d1f98c6
12. *image*: doc/extensions/https:/github.com/user-attachments/assets/fb04393c-a9da-4704-884b-2810ff69f59a
13. *image*: doc/extensions/https:/github.com/user-attachments/assets/678a06a5-ada9-4bb5-8f49-6e58549c8f32
14. *Image*: doc/extensions/https:/github.com/user-attachments/assets/f85380dc-e70b-4821-88a8-f1ec2c4e3cf6
15. *Image*: doc/extensions/https:/github.com/user-attachments/assets/64708065-3428-4eb3-82a5-e32d2d1f98c6
16. *Image*: doc/extensions/https:/github.com/user-attachments/assets/7c16bc7e-a9df-4afc-9736-2ee6a39919a9
17. *Image*: doc/extensions/https:/github.com/user-attachments/assets/adc556bb-7d5f-4d22-820a-a7daeb0ac72c
18. *Image*: doc/extensions/https:/github.com/user-attachments/assets/7f77bf1e-12b7-4745-a87b-40181a619733
19. *image*: doc/extensions/https:/github.com/user-attachments/assets/f67802fe-6b0c-48a5-9275-bff9f830ce29
20. *image*: doc/extensions/https:/github.com/user-attachments/assets/f90f7cc4-ff34-4481-9732-a0331a26502b
21. *image*: doc/extensions/https:/github.com/user-attachments/assets/f6bdeeec-48f7-48de-89a5-22236a52843f

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
